# detect fingerprinting
detectfp.js application/javascript
(function() {
	// Privacy cat
	// options: remove iframes, toggle each device/browser privacy, toggle script tracing
	const removeFrames = () => {
		const frames = document.querySelectorAll('iframe')
		for (let i = 0; i < frames.length; i++) {
			frames[i].parentNode.removeChild(iframes[i])
		}
	}
	// helpers
	const isFn = (x) => typeof x === 'function' ? x() : x
	const timer = (logStart) => {
		console.log(logStart)
		const start = Date.now()
		return (logEnd) => {
			const end = Date.now() - start
			console.log(`${logEnd}: ${end/1000} seconds`)
		}
	}
	const itemInList = (list, item) => list.indexOf(item) > -1
	const listRand = (list) => list[Math.floor(Math.random() * list.length)]
	const evenRand = (min, max) =>
		(Math.floor(Math.random() * ((max/2) - min + 1)) + min)*2
	const rand = (min, max) =>
		(Math.floor(Math.random() * (max - min + 1)) + min)
	const randomRGBA = () => {
	    const clr = () => Math.round(Math.random()*255)
	    return `rgba(${clr()},${clr()},${clr()},${Math.random().toFixed(1)})`
	}
	const randomFont = () => {
		const fontFamily = [
			'Arial','Arial Black','Arial Narrow','Courier','Courier New','Georgia','Helvetica',
			'Impact','Lucida Console','monospace','Tahoma','Times','Times New Roman','Verdana'
		]
		const fontSize = Math.floor((Math.random() * 100) + 12)
		const rand = Math.floor(Math.random()*fontFamily.length)
		return `${fontSize}px '${fontFamily[rand]}'`
	}
	const hashify = str => {
		let i, len, hash = 0x811c9dc5
		for (i = 0, len = str.length; i < len; i++) {
			hash = Math.imul(31, hash) + str.charCodeAt(i)|0
		}
		return ("0000000" + (hash >>> 0).toString(16)).substr(-8)
	}
	// randomize
	const randomizationTime = timer('🔥Computing randomization...')
	const randomized = { browser: {}, device: {} }
	// todo: https://www.whatismybrowser.com/guides/the-latest-version/
	const randomizify = (env, prop, val, canLie = true) => {
		if (canLie) { randomized[env][prop] = [prop, isFn(val)] }
		return val
	}
	const doNotTrack = () => {
		const val = listRand(['0','1'])
		return () => val
	}
	function canLieTouch() {
	  const userAgent = navigator.userAgent
	  const os = (
	    /windows phone/ig.test(userAgent)? 'Windows Phone':
	    /win(dows|16|32|64|95|98|nt)|wow64/ig.test(userAgent)? 'Windows':
	    /android/ig.test(userAgent)? 'Android': 
	    /linux/ig.test(userAgent)? 'Linux': 
	    /ios/ig.test(userAgent)? 'iOS': 
	    /mac/ig.test(userAgent)? 'Mac':
	    /cros/ig.test(userAgent)? 'CrOS':
	    'Other' 
	  )
	  const touchOS = (/^(Windows(| Phone)|CrOS|Android|iOS)$/ig.test(os))
	  //let touchAPI = ('ontouchstart' in window)
	  //try { document.createEvent('TouchEvent') }
	  //catch (err) { touchAPI = false }
	  return () => touchOS //&& touchAPI
	}
	const canLieTouchComputed = canLieTouch()
	const maxTouchPoints = () => { const val = rand(1, 10); return () => val }
	const hardwareConcurrency = () => { const val = rand(1, 16); return () => val }
	const deviceMemory = () => { const val = evenRand(2, 32); return () => val }
	// https://gs.statcounter.com/screen-resolution-stats
	const screenFingerprint = () => {
		const val = listRand([{w:1920,h:1080},{w:1440,h:900},{w:1280,h:800},{w:1600,h:900}])
		val.asrw = val.w-rand(1, 20)
		val.asrh = val.h-rand(1, 20)
		val.cDepth = listRand([24, 32, 48])
		val.pDepth = listRand([24, 32, 48])
		return () => val
	}
	const screenFingerprintComputed = screenFingerprint()
	const canvasDataURL = () => {
		const canvas = document.createElement('canvas')
		const txt = '🚀 Private'
		const context = canvas.getContext('2d')
		context.textBaseline = 'top'
		context.textBaseline = 'alphabetic'
		context.font = randomFont()
		context.fillStyle = randomRGBA()
		context.fillRect(125, 1, 62, 20)
		context.fillText(txt, 2, 15)
		const dataURL = canvas.toDataURL()
		randomized.browser.toDataURL = ['HTMLCanvasElement.toDataURL', hashify(dataURL)]
		return () => dataURL
	}
	const audioBufferChannelData = () => {
		const doubleSize = (arr) => arr.concat(arr) // helper
		const context = new AudioContext()
		const channels = 2
		const frameCount = (context.sampleRate*2)/2000 // reduce initial size for randomization
		const audioBuffer = context.createBuffer(2, frameCount, context.sampleRate)
		let pcmData = audioBuffer.getChannelData(0)
		for (let i = 0; i < frameCount; i++) { pcmData[i] = Math.random() * 2 - 1 } // randomize
		let arr = Array.from(pcmData) // convert to Array
		const randomChannelData = arr // store random data
		for (let y = 0; y < 10; y++) { arr = doubleSize(arr) } // increase size
		pcmData = new Float32Array(arr) // convert back to Float32Array
		randomized.browser.getChannelData = ['AudioBuffer.getChannelData', hashify(JSON.stringify(randomChannelData))]
		return () => pcmData
	}
	const webglRenderer = () => {
		//https://www.primegrid.com/gpu_list.php
		const renderers = [
			{
				gpu: 'NVIDIA GeForce RTX',
				model: [
					'2080 SUPER',
					'2080 Ti',
					'2080',
					'2070 SUPER',
					'2070',
					'2060'
				]
			},
			{	
				gpu: 'NVIDIA GeForce GTX',
				model: [
					'1080 Ti',
					'1080',
					'1070 Ti',
					'1070',
					'1660 Ti',
					'1660',
					'1650',
					'1060',
					'1050 Ti',
					'1050'
				]
			},
			{
				gpu: 'AMD Radeon',
				model: [
					'VII',
					'HD 7950 Compute Engine',
					'(TM) R9 Fury Series', 
					'Pro 580 Compute Engine',
					'RX 570 Compute Engine', 
					'(TM) RX Vega 11 Graphics',
					'RX Vega 56 Compute Engine'
				]
			},
			{
				gpu: 'Radeon',
				model: [
					'RX Vega',
					'RX 580 Series',
					'RX 570 Series',
					'RX 560 Series',
					'(TM) RX 480 Graphics'
				] 
			}
		]
		const getParameter = WebGLRenderingContext.prototype.getParameter
		const randomRenderer = listRand(renderers)
		const randomGpu = randomRenderer.gpu
		const randomModel = listRand(randomRenderer.model)
		const randomizedRenderer = `${randomGpu} ${randomModel}`
		const extension = { 37446: `ANGLE (${randomizedRenderer} vs_${rand(1,5)}_0 ps_${rand(1,5)}_0)` }
		randomized.device.getParameter = ['WebGL Renderer', randomizedRenderer]
		return function(x) { return extension[x]? extension[x]: getParameter.apply(this, arguments) }
	}
	// randomized & cached: prevent recompute on property reads
	const cachedRandomized = {
		doNotTrack: randomizify('browser', 'doNotTrack', doNotTrack()),
		maxTouchPoints: randomizify('device', 'maxTouchPoints', maxTouchPoints(), canLieTouchComputed()),
		hardwareConcurrency: randomizify('device', 'hardwareConcurrency', hardwareConcurrency()),
		deviceMemory: randomizify('device', 'deviceMemory', deviceMemory()),
		screenWidth: randomizify('device', 'screen.width', screenFingerprintComputed().w),
		screenHeight: randomizify('device', 'screen.height', screenFingerprintComputed().h),
		screenAvailWidth: randomizify('device', 'screen.availWidth', screenFingerprintComputed().asrw),
		screenAvailHeight: randomizify('device', 'screen.availHeight', screenFingerprintComputed().asrh),
		screenColorDepth: randomizify('device', 'screen.colorDepth', screenFingerprintComputed().cDepth),
		screenPixelDepth: randomizify('device', 'screen.pixelDepth', screenFingerprintComputed().pDepth),
		canvasDataURL: canvasDataURL(),
		audioBufferChannelData: audioBufferChannelData(),
		webglRenderer: webglRenderer()
	}
	randomizationTime(`⏱Randomization complete`)
	// blocked
	const blocked = { browser: {}, device: {} }
	const blockify = (env, prop, val, canLie = true) => {
		if (canLie) { blocked[env][prop] = [prop, (val !== ''? JSON.stringify(val): "''")] }
		return () => val
	}
	const resolvedOptionsTimeZone = () => {
		const options = Intl.DateTimeFormat().resolvedOptions()
		options.timeZone = 'UTC'
		blocked.device.timeZone = ['timeZone', 'UTC']
		return () => options
	}
	// blocked & cached: prevent recompute on property reads
	const cachedBlocked = {
		mimeTypes: blockify('browser', 'mimeTypes', []),
		plugins: blockify('browser', 'plugins', []),
		vendor: blockify('browser', 'vendor', ''),
		getVoices: blockify('browser', 'getVoices', []),
		connection: blockify('device', 'connection', undefined),
		getBattery: blockify('device', 'getBattery', undefined),
		getGamepads: blockify('device', 'getGamepads', []),
		resolvedOptionsTimeZone: resolvedOptionsTimeZone(),
		timezoneOffset: blockify('device', 'timezoneOffset', 0),
		createDataChannel: blockify('device', 'RTCPeerConnection.createDataChannel', undefined),
		createOffer: blockify('device', 'RTCPeerConnection.createOffer', undefined),
		setRemoteDescription: blockify('device', 'RTCPeerConnection.setRemoteDescription', undefined)
	}
	// structs
	const navigatorProps = {
		appVersion: navigator.appVersion,
		appCodeName: navigator.appCodeName,
		deviceMemory: cachedRandomized.deviceMemory(),
		doNotTrack: cachedRandomized.doNotTrack(),
		hardwareConcurrency: cachedRandomized.hardwareConcurrency(),
		languages: navigator.languages,
		maxTouchPoints: canLieTouchComputed()? cachedRandomized.maxTouchPoints(): navigator.maxTouchPoints,
		mimeTypes: cachedBlocked.mimeTypes(),
		platform: navigator.platform,
		plugins: cachedBlocked.plugins(),
		userAgent: navigator.userAgent,
		vendor: cachedBlocked.vendor(),
		connection: cachedBlocked.connection()
	}
	if ('getBattery' in navigator) { navigatorProps.getBattery = () => cachedBlocked.getBattery() }
	if ('getGamepads' in navigator) { navigatorProps.getGamepads = () => cachedBlocked.getGamepads() }
	const screenProps = {
		width: cachedRandomized.screenWidth,
		height: cachedRandomized.screenHeight,
		availWidth: cachedRandomized.screenAvailWidth,
		availHeight: cachedRandomized.screenAvailHeight,
		availTop: screen.availTop,
		availLeft: screen.availLeft,
		colorDepth: cachedRandomized.screenColorDepth,
		pixelDepth: cachedRandomized.screenPixelDepth
	}
	const dateProps = {
		getTimezoneOffset: () => cachedBlocked.timezoneOffset()
	}
	const intlProps = {
		resolvedOptions: () => cachedBlocked.resolvedOptionsTimeZone()
	}
	const mathProps = {
		acos: Math.acos,
		acosh: Math.acosh,
		asin: Math.asin,
		asinh: Math.asinh,
		cosh: Math.cosh,
		expm1: Math.expm1,
		sinh: Math.sinh
	}
	const mediaDeviceProps = {
		enumerateDevices: navigator.mediaDevices.enumerateDevices
	}
	const videoElementProps = {
		canPlayType: HTMLVideoElement.prototype.canPlayType
	}
	const mediaElementProps = {
		canPlayType: HTMLMediaElement.prototype.canPlayType
	}
	const mediaSourceProps = {
		isTypeSupported: MediaSource.isTypeSupported
	}
	const mediaRecorderProps = {
		isTypeSupported: MediaRecorder.isTypeSupported
	}
	const speechProps = {
		getVoices: () => cachedBlocked.getVoices()
	}
	const performanceProps = {
		now: performance.now
	}
	const elemRectProps = {
		getBoundingClientRect: Element.prototype.getBoundingClientRect,
		getClientRects: Element.prototype.getClientRects
	}
	const rangeRectProps = {
		getBoundingClientRect: Range.prototype.getBoundingClientRect,
		getClientRects: Range.prototype.getClientRects
	}
	const webglProps = {
		shaderSource: WebGLRenderingContext.prototype.shaderSource,
		getExtension: WebGLRenderingContext.prototype.getExtension,
		getParameter: cachedRandomized.webglRenderer,
		getSupportedExtensions: WebGLRenderingContext.prototype.getSupportedExtensions
	}
	const canvasProps = {
		toDataURL: () => cachedRandomized.canvasDataURL(),
		toBlob: HTMLCanvasElement.prototype.toBlob
	}
	const canvasContextProps = {
		getImageData: CanvasRenderingContext2D.prototype.getImageData,
		isPointInPath: CanvasRenderingContext2D.prototype.isPointInPath,
		isPointInStroke: CanvasRenderingContext2D.prototype.isPointInStroke,
		measureText: CanvasRenderingContext2D.prototype.measureText,
	}
	const audioProps = {
		createAnalyser: AudioContext.prototype.createAnalyser,
		createOscillator: AudioContext.prototype.createOscillator,
	}
	const audioBufferProps = {
		getChannelData: () => cachedRandomized.audioBufferChannelData()
	}
	const webRTCProps = {
		createDataChannel: () => cachedBlocked.createDataChannel(),
		createOffer: () => cachedBlocked.createOffer(),
		setRemoteDescription: () => cachedBlocked.setRemoteDescription()
	}
	// Log Randomized & Blocked
	const style = `color:aaa;background:#e2d7d752`
	const randomizedBrowserKeys = Object.keys(randomized.browser)
	const randomizedDeviceKeys = Object.keys(randomized.device)
	const blockedBrowserKeys = Object.keys(blocked.browser)
	const blockedDeviceKeys = Object.keys(blocked.device)
	const hash = hashify(JSON.stringify(randomized))
	console.group(
		`🧪Randomized ${randomizedBrowserKeys.length+randomizedDeviceKeys.length} properties (id: ${hash})`
	)
		console.group('Browser')
		randomizedBrowserKeys.forEach(key => {
			const prop = randomized.browser[key][0]
			const val = randomized.browser[key][1]
			console.log(`%c${prop}: ${val}`, style)
		})
		console.groupEnd()
		console.group('Device')
		randomizedDeviceKeys.forEach(key => {
			const prop = randomized.device[key][0]
			const val = randomized.device[key][1]
			console.log(`%c${prop}: ${val}`, style)
		})
		console.groupEnd()
	console.groupEnd()
	console.groupCollapsed(
		`🔌Blocked ${blockedBrowserKeys.length+blockedDeviceKeys.length} properties`
	)
		console.group('Browser')
		blockedBrowserKeys.forEach(key => {
			const prop = blocked.browser[key][0]
			const val = blocked.browser[key][1]
			console.log(`%c${prop}: ${val}`, style)
		})
		console.groupEnd()
		console.group('Device')
		blockedDeviceKeys.forEach(key => {
			const prop = blocked.device[key][0]
			const val = blocked.device[key][1]
			console.log(`%c${prop}: ${val}`, style)
		})
		console.groupEnd()
	console.groupEnd()
	// API with Ranking per Unique Impact and Longterm State
	const queryAPI = 'https://developer.mozilla.org/en-US/search?q='
	const propAPI = {
		appVersion: ['navigator.appVersion', 2],
		appCodeName: ['navigator.appCodeName', 1],
		deviceMemory: ['navigator.deviceMemory', 1],
		doNotTrack: ['navigator.doNotTrack', 1],
		hardwareConcurrency: ['navigator.hardwareConcurrency', 1],
		languages: ['navigator.languages', 1],
		maxTouchPoints: ['navigator.maxTouchPoints', 1],
		mimeTypes: ['navigator.mimeTypes', 1],
		platform: ['navigator.platform', 1],
		plugins: ['navigator.plugins', 1],
		userAgent: ['navigator.userAgent', 2],
		vendor: ['navigator.vendor', 1],
		connection: ['navigator.connection', 1],
		getBattery: ['navigator.getBattery', 1],
		getGamepads: ['navigator.getGamepads', 1],
		width: ['screen.width', 1],
		height: ['screen.height', 1],
		availWidth: ['screen.availWidth', 1],
		availHeight: ['screen.availHeight', 1],
		availTop: ['screen.availTop', 1],
		availLeft: ['screen.availLeft', 1],
		colorDepth: ['screen.colorDepth', 1],
		pixelDepth: ['screen.pixelDepth', 1],
		getTimezoneOffset: ['Date.prototype.getTimezoneOffset', 1],
		resolvedOptions: ['Intl.DateTimeFormat.prototype.resolvedOptions', 2],
		acos: ['acos: Math.acos', 1],
		acosh: ['Math.acosh', 1],
		asin: ['Math.asin', 1],
		asinh: ['Math.asinh', 1],
		cosh: ['Math.cosh', 1],
		expm1: ['Math.expm1', 1],
		sinh: ['Math.sinh', 1],
		enumerateDevices: ['navigator.mediaDevices.enumerateDevices', 1],
		canPlayType: ['prototype.canPlayType', 1],
		isTypeSupported: ['isTypeSupported', 1],
		getVoices: ['speechSynthesis.getVoices', 1],
		now: ['performance.now', 1],
		getBoundingClientRect: ['prototype.getBoundingClientRect', 2],
		getClientRects: ['prototype.getClientRects', 2],
		offsetWidth: ['HTMLElement.prototype.offsetWidth', 1],
		offsetHeight: ['HTMLElement.prototype.offsetHeight', 1],
		shaderSource: ['WebGLRenderingContext.prototype.shaderSource', 6],
		getExtension: ['WebGLRenderingContext.prototype.getExtension', 2],
		getParameter: ['WebGLRenderingContext.prototype.getParameter', 2],
		getSupportedExtensions: ['WebGLRenderingContext.prototype.getSupportedExtensions', 4],
		toDataURL: ['HTMLCanvasElement.prototype.toDataURL', 6],
		toBlob: ['HTMLCanvasElement.prototype.toBlob', 6],
		getImageData: ['CanvasRenderingContext2D.prototype.getImageData', 6],
		isPointInPath: ['CanvasRenderingContext2D.prototype.isPointInPath', 1],
		isPointInStroke: ['CanvasRenderingContext2D.prototype.isPointInStroke', 1],
		measureText: ['CanvasRenderingContext2D.prototype.measureText', 1],
		font: ['CanvasRenderingContext2D.prototype.font', 1],
		createAnalyser: ['AudioContext.prototype.createAnalyser', 6],
		createOscillator: ['AudioContext.prototype.createOscillator', 6],
		getChannelData: ['AudioBuffer.prototype.getChannelData', 6],
		createDataChannel: ['RTCPeerConnection.prototype.createDataChannel', 6],
		createOffer: ['RTCPeerConnection.prototype.createOffer', 6]
	}
	// watcher
	let rankCounter = 0
	let watching = true
	const domain = window.location.hostname
	const fingerprintingRank = 12
	const propsRead = []
	const propsReadAll = {}
	const watch = (prop) => {
		const propDescription = propAPI[prop][0]
		const propRank = propAPI[prop][1]
		const headingStyle = `background:#bcf4de73`
		const trace = () => {
			console.groupCollapsed(`Script read ${propDescription}`)
			console.log(`%cAPI Reference:`, headingStyle)
			console.log(queryAPI+propDescription)
			console.log(`%cAttempting to trace the source (refresh to retry)...`, headingStyle)
			console.trace(document.currentScript?document.currentScript.src:'')
			console.groupEnd()
		}
		const newPropRead = !itemInList(propsRead, propDescription)
		propsReadAll[propDescription]? propsReadAll[propDescription]++: propsReadAll[propDescription]=1
		if (newPropRead) {
			rankCounter += propRank
			propsRead.push(propDescription)
		}
		// counter types
		if (watching && rankCounter >= fingerprintingRank) {
			const warnStyle = `color:red;border:1px solid red;font-weight:bold;padding:2px;`
			const warning = `⚔️Meow! Detected Fingerprinting!`
			console.log('%c'+warning, warnStyle)
			console.groupCollapsed(`📔Data Collection Stats and Study Resources`)
			console.log(`%cAmount of data read that can be compiled to uniquely identify and track this browser: `, headingStyle)
			console.log(propsReadAll)
			console.log(`%cSearch this host's Privacy Policy:`, headingStyle)
			console.log(`https://duckduckgo.com/?q=%22${domain}%22+%22privacy%22+%22policy%22`)
				console.groupCollapsed(`📋Testing Resources`)
				console.log('https://privacycheck.sec.lrz.de/')
				console.log('https://ghacksuserjs.github.io/TorZillaPrint/TorZillaPrint.html')
				console.log('https://browserleaks.com/')
				console.log('https://webbrowsertools.com/')
				console.log('https://www.nothingprivate.ml')
				console.log('https://fingerprintjs.com/demo')
				console.log('https://bestiejs.github.io/platform.js/')
				console.log('https://webglreport.com')
				console.groupEnd()
				console.groupCollapsed(`📝Source Code Resources`)
				console.log('https://old.darkwavetech.com/fingerprint/fingerprint_code.html')
				console.log('https://github.com/Valve/fingerprintjs2')
				console.log('https://github.com/JackSpirou/ClientJS')
				console.groupEnd()
				console.groupCollapsed(`📚Research Resources`)
				console.log('https://plaperdr.github.io/')
				console.log('https://docs.google.com/spreadsheets/d/1ZB1zINfGFcrcFzNg4eytRnBQN3nBoKHua2jhV_X6W80')
				console.groupEnd()
			console.groupEnd()
			watching = false
		}
		return newPropRead? trace: ()=>{}
	}
	// difinify
	function definify(struct) {
		const redefinedProps = {}
		Object.keys(struct).forEach(prop => {
			redefinedProps[prop] = { get: () => { watch(prop)(); return struct[prop] } }
		})
		return redefinedProps
	}
	function redefine(root, typeOfAttempt = '') {
		Object.defineProperties(root.navigator, definify(navigatorProps))
		Object.defineProperties(root.screen, definify(screenProps))
		Object.defineProperties(root.Date.prototype, definify(dateProps))
		Object.defineProperties(root.Intl.DateTimeFormat.prototype, definify(intlProps))
		Object.defineProperties(root.Math, definify(mathProps))
		Object.defineProperties(root.navigator.mediaDevices, definify(mediaDeviceProps))
		Object.defineProperties(root.HTMLVideoElement.prototype, definify(videoElementProps))
		Object.defineProperties(root.HTMLMediaElement.prototype, definify(mediaElementProps))
		Object.defineProperties(root.MediaSource, definify(mediaSourceProps))
		Object.defineProperties(root.MediaRecorder, definify(mediaRecorderProps))
		Object.defineProperties(root.speechSynthesis, definify(speechProps))
		Object.defineProperties(root.performance, definify(performanceProps))
		Object.defineProperties(root.Element.prototype, definify(elemRectProps))
		Object.defineProperties(root.Range.prototype, definify(rangeRectProps))
		Object.defineProperties(root.WebGLRenderingContext.prototype, definify(webglProps))
		Object.defineProperties(root.HTMLCanvasElement.prototype, definify(canvasProps))
		Object.defineProperties(root.CanvasRenderingContext2D.prototype, definify(canvasContextProps))
		Object.defineProperties(root.AudioContext.prototype, definify(audioProps))
		Object.defineProperties(root.AudioBuffer.prototype, definify(audioBufferProps))
		Object.defineProperties(root.AudioBuffer.prototype, definify(audioBufferProps))
		Object.defineProperties(root.RTCPeerConnection.prototype, definify(webRTCProps))
	}
	const redefineTime = timer(`🔨Redefining properties...`)
	redefine(window)
	redefineTime(`⏱Redefining complete`)
})()
