# detect fingerprinting
detectfp.js application/javascript
(function() {
	// helpers
	const itemInList = (list, item) => list.indexOf(item) > -1
	const listRand = (list) => list[Math.floor(Math.random() * list.length)]
	const evenRand = (min, max) =>
		(Math.floor(Math.random() * ((max/2) - min + 1)) + min)*2
	const rand = (min, max) =>
		(Math.floor(Math.random() * (max - min + 1)) + min)
	const randomRGBA = () => {
	    const clr = () => Math.round(Math.random()*255)
	    return `rgba(${clr()},${clr()},${clr()},${Math.random().toFixed(1)})`
	}
	const randomFont = () => {
		const fontFamily = [
			'Arial','Arial Black','Arial Narrow','Courier','Courier New','Georgia','Helvetica',
			'Impact','Lucida Console','monospace','Tahoma','Times','Times New Roman','Verdana'
		]
		const fontSize = Math.floor((Math.random() * 100) + 12)
		const rand = Math.floor(Math.random()*fontFamily.length)
		return `${fontSize}px '${fontFamily[rand]}'`
	}
	const hashify = str => {
		let i, len, hash = 0x811c9dc5
		for(i = 0, len = str.length; i < len; i++) {
			hash = Math.imul(31, hash) + str.charCodeAt(i)|0
	    	}
		return ("0000000" + (hash >>> 0).toString(16)).substr(-8)
	}
	// randomize
	console.log('🔥 Computing randomization...')
	const before = Date.now()
	const randomized = {}
	const doNotTrack = () => {
		const val = listRand(['0','1', 'unspecified'])
		randomized.doNotTrack = ['navigator.doNotTrack', val]
		return () => val
	}
	function canLieTouch() {
	  const userAgent = navigator.userAgent
	  const os = (
	    /windows phone/ig.test(userAgent)? 'Windows Phone':
	    /win(dows|16|32|64|95|98|nt)|wow64/ig.test(userAgent)? 'Windows':
	    /android/ig.test(userAgent)? 'Android': 
	    /linux/ig.test(userAgent)? 'Linux': 
	    /ios/ig.test(userAgent)? 'iOS': 
	    /mac/ig.test(userAgent)? 'Mac':
	    /cros/ig.test(userAgent)? 'CrOS':
	    'Other' 
	  )
	  const touchOS = (/^(Windows(| Phone)|CrOS|Android|iOS)$/ig.test(os))
	  let touchAPI = ('ontouchstart' in window)
	  try { document.createEvent('TouchEvent') }
	  catch (err) { touchAPI = false }
	  return () => touchOS && touchAPI
	}
	const canLieTouchComputed = canLieTouch()
	const maxTouchPoints = () => {
		const val = rand(1, 10)
		if (canLieTouchComputed()) { randomized.maxTouchPoints = ['navigator.maxTouchPoints', val] }
		return () => val
	}
	const hardwareConcurrency = () => {
		const val = rand(1, 16)
		randomized.hardwareConcurrency = ['navigator.hardwareConcurrency', val]
		return () => val
	}
	const deviceMemory = () => {
		const val = evenRand(2, 32)
		randomized.deviceMemory = ['navigator.deviceMemory', val]
		return () => val
	}
	const screenRatio = () => {
		const val = listRand([{w:1920,h:1080},{w:1440,h:900},{w:1280,h:800},{w:1600,h:900}])
		return () => val
	}
	const availScreenRatio = () => {
		const val = listRand([{w:1920,h:1080},{w:1440,h:900},{w:1280,h:800},{w:1600,h:900}])
		val.w = val.w-rand(1, 20)
		val.h = val.h-rand(1, 20)
		return () => val
	}
	const screenRandomized = (prop, val) => {
		randomized[prop] = [prop, val]
		return val
	}
	const canvasDataURL = () => {
		const canvas = document.createElement('canvas')
		const txt = '🚀 Private'
		const context = canvas.getContext('2d')
		context.textBaseline = 'top'
		context.textBaseline = 'alphabetic'
		context.font = randomFont()
		context.fillStyle = randomRGBA()
		context.fillRect(125, 1, 62, 20)
		context.fillText(txt, 2, 15)
		const dataURL = canvas.toDataURL()
		randomized.toDataURL = ['HTMLCanvasElement.toDataURL', hashify(dataURL)]
		return () => dataURL
	}
	const audioBufferChannelData = () => {
		const doubleSize = (arr) => arr.concat(arr) // helper
		const context = new AudioContext()
		const channels = 2
		const frameCount = (context.sampleRate*2)/2000 // reduce initial size for randomization
		const audioBuffer = context.createBuffer(2, frameCount, context.sampleRate)
		let pcmData = audioBuffer.getChannelData(0)
		for (let i = 0; i < frameCount; i++) { pcmData[i] = Math.random() * 2 - 1 } // randomize
		let arr = Array.from(pcmData) // convert to Array
		const randomChannelData = arr // store random data
		for (let i = 0; i < 10; i++) { arr = doubleSize(arr) } // increase size
		pcmData = new Float32Array(arr) // convert back to Float32Array
		randomized.getChannelData = ['AudioBuffer.getChannelData', hashify(JSON.stringify(randomChannelData))]
		return () => pcmData
	}
	// cached and randomized
	const cachedRandomized = {
		doNotTrack: doNotTrack(),
		maxTouchPoints: maxTouchPoints(),
		hardwareConcurrency: hardwareConcurrency(),
		deviceMemory: deviceMemory(),
		screenRatio: screenRatio(),
		availScreenRatio: availScreenRatio(),
		canvasDataURL: canvasDataURL(),
		audioBufferChannelData: audioBufferChannelData()
	}
	const after = Date.now()
	console.log(`⏱ Finished randomization in ${(after - before)/1000} seconds`)
	// blocked
	const blocked = {}
	const mimeTypes = () => { const val = []; blocked.mimeTypes = ['navigator.mimeTypes', '[]']; return () => val }
	const plugins = () => { const val = []; blocked.plugins = ['navigator.plugins', '[]']; return () => val }
	const vendor = () => { const val = ''; blocked.vendor = ['navigator.vendor', '""']; return () => val }
	const getVoices = () => { const val = []; blocked.getVoices = ['speechSynthesis.getVoices', '[]']; return () => val }
	const connection = () => { const val = undefined; blocked.connection = ['navigator.connection', 'undefined']; return () => val }
	const getGamepads = () => { const val = []; blocked.getGamepads = ['navigator.getGamepads', '[]']; return () => val }
	const getBattery = () => { const val = undefined; blocked.getBattery = ['navigator.getBattery', 'undefined']; return () => val }
	// cached
	const cachedBlocked = {
		mimeTypes: mimeTypes(),
		plugins: plugins(),
		vendor: vendor(),
		getVoices: getVoices(),
		connection: connection(),
		getBattery: getBattery(),
		getGamepads: getGamepads()
	}
	// structs
	const navigatorProps = {
		appVersion: navigator.appVersion,
		appCodeName: navigator.appCodeName,
		deviceMemory: cachedRandomized.deviceMemory(),
		doNotTrack: cachedRandomized.doNotTrack(),
		hardwareConcurrency: cachedRandomized.hardwareConcurrency(),
		languages: navigator.languages,
		maxTouchPoints: canLieTouchComputed()? cachedRandomized.maxTouchPoints(): navigator.maxTouchPoints,
		mimeTypes: cachedBlocked.mimeTypes(),
		platform: navigator.platform,
		plugins: cachedBlocked.plugins(),
		userAgent: navigator.userAgent,
		vendor: cachedBlocked.vendor(),
		connection: cachedBlocked.connection()
	}
	if ('getBattery' in navigator) { navigatorProps.getBattery = () => cachedBlocked.getBattery() }
	if ('getGamepads' in navigator) { navigatorProps.getGamepads = () => cachedBlocked.getGamepads() }
	const screenProps = {
		width: screenRandomized('screen.width', cachedRandomized.screenRatio().w),
		height: screenRandomized('screen.height', cachedRandomized.screenRatio().h),
		availWidth: screenRandomized('screen.availWidth', cachedRandomized.availScreenRatio().w),
		availHeight: screenRandomized('screen.availHeight', cachedRandomized.availScreenRatio().h),
		availTop: screen.availTop,
		availLeft: screen.availLeft,
		colorDepth: screen.colorDepth,
		pixelDepth: screen.pixelDepth
	}
	const dateProps = {
		getTimezoneOffset: Date.prototype.getTimezoneOffset
	}
	const intlProps = {
		resolvedOptions: Intl.DateTimeFormat.prototype.resolvedOptions
	}
	const mathProps = {
		acos: Math.acos,
		acosh: Math.acosh,
		asin: Math.asin,
		asinh: Math.asinh,
		cosh: Math.cosh,
		expm1: Math.expm1,
		sinh: Math.sinh
	}
	const mediaDeviceProps = {
		enumerateDevices: navigator.mediaDevices.enumerateDevices
	}
	const videoElementProps = {
		canPlayType: HTMLVideoElement.prototype.canPlayType
	}
	const mediaElementProps = {
		canPlayType: HTMLMediaElement.prototype.canPlayType
	}
	const mediaSourceProps = {
		isTypeSupported: MediaSource.isTypeSupported
	}
	const mediaRecorderProps = {
		isTypeSupported: MediaRecorder.isTypeSupported
	}
	const speechProps = {
		getVoices: () => cachedBlocked.getVoices()
	}
	const performanceProps = {
		now: performance.now
	}
	const elemRectProps = {
		getBoundingClientRect: Element.prototype.getBoundingClientRect,
		getClientRects: Element.prototype.getClientRects
	}
	const rangeRectProps = {
		getBoundingClientRect: Range.prototype.getBoundingClientRect,
		getClientRects: Range.prototype.getClientRects
	}
	const webglProps = {
		shaderSource: WebGLRenderingContext.prototype.shaderSource,
		getExtension: WebGLRenderingContext.prototype.getExtension,
		getParameter: WebGLRenderingContext.prototype.getParameter,
		getSupportedExtensions: WebGLRenderingContext.prototype.getSupportedExtensions
	}
	const canvasProps = {
		toDataURL: () => cachedRandomized.canvasDataURL(),
		toBlob: HTMLCanvasElement.prototype.toBlob
	}
	const canvasContextProps = {
		getImageData: CanvasRenderingContext2D.prototype.getImageData,
		isPointInPath: CanvasRenderingContext2D.prototype.isPointInPath,
		isPointInStroke: CanvasRenderingContext2D.prototype.isPointInStroke,
		measureText: CanvasRenderingContext2D.prototype.measureText,
	}
	const audioProps = {
		createAnalyser: AudioContext.prototype.createAnalyser,
		createOscillator: AudioContext.prototype.createOscillator,
	}
	const audioBufferProps = {
		getChannelData: () => cachedRandomized.audioBufferChannelData()
	}
	// Log Randomized & Blocked
	const style = `color:aaa;background:#f9f9f9`
	const randomizedKeys = Object.keys(randomized)
	const blockedKeys = Object.keys(blocked)
	const hash = hashify(JSON.stringify(randomized))
	console.groupCollapsed(
		`🧪 Randomized ${randomizedKeys.length} properties (id: ${hash})`
	)
	randomizedKeys.forEach(key => {
		const prop = randomized[key][0]
		const val = randomized[key][1]
		console.log(`%c${prop}: ${val}`, style)
	})
	console.groupEnd()
	console.groupCollapsed(
		`🔌 Blocked ${blockedKeys.length} properties`
	)
	blockedKeys.forEach(key => {
		const prop = blocked[key][0]
		const val = blocked[key][1]
		console.log(`%c${prop}: ${val}`, style)
	})
	console.groupEnd()
	// API with Ranking per Unique Impact and Longterm State
	const queryAPI = 'https://developer.mozilla.org/en-US/search?q='
	const propAPI = {
		appVersion: ['navigator.appVersion', 2],
		appCodeName: ['navigator.appCodeName', 1],
		deviceMemory: ['navigator.deviceMemory', 1],
		doNotTrack: ['navigator.doNotTrack', 1],
		hardwareConcurrency: ['navigator.hardwareConcurrency', 1],
		languages: ['navigator.languages', 1],
		maxTouchPoints: ['navigator.maxTouchPoints', 1],
		mimeTypes: ['navigator.mimeTypes', 1],
		platform: ['navigator.platform', 1],
		plugins: ['navigator.plugins', 1],
		userAgent: ['navigator.userAgent', 2],
		vendor: ['navigator.vendor', 1],
		connection: ['navigator.connection', 1],
		getBattery: ['navigator.getBattery', 1],
		getGamepads: ['navigator.getGamepads', 1],
		width: ['screen.width', 1],
		height: ['screen.height', 1],
		availWidth: ['screen.availWidth', 1],
		availHeight: ['screen.availHeight', 1],
		availTop: ['screen.availTop', 1],
		availLeft: ['screen.availLeft', 1],
		colorDepth: ['screen.colorDepth', 1],
		pixelDepth: ['screen.pixelDepth', 1],
		getTimezoneOffset: ['Date.prototype.getTimezoneOffset', 1],
		resolvedOptions: ['Intl.DateTimeFormat.prototype.resolvedOptions', 2],
		acos: ['acos: Math.acos', 1],
		acosh: ['Math.acosh', 1],
		asin: ['Math.asin', 1],
		asinh: ['Math.asinh', 1],
		cosh: ['Math.cosh', 1],
		expm1: ['Math.expm1', 1],
		sinh: ['Math.sinh', 1],
		enumerateDevices: ['navigator.mediaDevices.enumerateDevices', 1],
		canPlayType: ['prototype.canPlayType', 1],
		isTypeSupported: ['isTypeSupported', 1],
		getVoices: ['speechSynthesis.getVoices', 1],
		now: ['performance.now', 1],
		getBoundingClientRect: ['prototype.getBoundingClientRect', 2],
		getClientRects: ['prototype.getClientRects', 2],
		offsetWidth: ['HTMLElement.prototype.offsetWidth', 1],
		offsetHeight: ['HTMLElement.prototype.offsetHeight', 1],
		shaderSource: ['WebGLRenderingContext.prototype.shaderSource', 6],
		getExtension: ['WebGLRenderingContext.prototype.getExtension', 2],
		getParameter: ['WebGLRenderingContext.prototype.getParameter', 2],
		getSupportedExtensions: ['WebGLRenderingContext.prototype.getSupportedExtensions', 4],
		toDataURL: ['HTMLCanvasElement.prototype.toDataURL', 6],
		toBlob: ['HTMLCanvasElement.prototype.toBlob', 6],
		getImageData: ['CanvasRenderingContext2D.prototype.getImageData', 6],
		isPointInPath: ['CanvasRenderingContext2D.prototype.isPointInPath', 1],
		isPointInStroke: ['CanvasRenderingContext2D.prototype.isPointInStroke', 1],
		measureText: ['CanvasRenderingContext2D.prototype.measureText', 1],
		font: ['CanvasRenderingContext2D.prototype.font', 1],
		createAnalyser: ['AudioContext.prototype.createAnalyser', 6],
		createOscillator: ['AudioContext.prototype.createOscillator', 6],
		getChannelData: ['AudioBuffer.prototype.getChannelData', 6]
	}
	// watcher
	let rankCounter = 0
	let watching = true
	const domain = window.location.hostname
	const fingerprintingRank = 12
	const propsRead = []
	const propsReadAll = {}
	const watch = (prop) => {
		const propDescription = propAPI[prop][0]
		const propRank = propAPI[prop][1]
		const headingStyle = `background:#bcf4de73`
		const trace = () => {
			const emojis = propRank >= 6? '🥵 ': propRank >= 4? '🥶 ': propRank >= 3? '😱 ': propRank >=2 ? '😨 ': ''
			console.groupCollapsed(`${emojis} Script read ${propDescription}`)
			console.log(`%cAPI Reference:`, headingStyle)
			console.log(queryAPI+propDescription)
			console.log(`%cAttempting to trace the source (refresh to retry)...`, headingStyle)
			console.trace(document.currentScript?document.currentScript.src:'')
			console.groupEnd()
		}
		const newPropRead = !itemInList(propsRead, propDescription)
		propsReadAll[propDescription]? propsReadAll[propDescription]++: propsReadAll[propDescription]=1
		if (newPropRead) {
			rankCounter += propRank
			propsRead.push(propDescription)
		}
		// counter types
		if (watching && rankCounter >= fingerprintingRank) {
			const warnStyle = `color:green;border:2px solid green;font-weight:bold;padding:5px;`
			const warning = `⚔️ Detected excessive data collection (fingerprinting tactics)!`
			console.warn('%c'+warning, warnStyle)
			console.groupCollapsed(`📔 Data Collection Stats and Study Resources`)
			console.log(`%cAmount of data read that can be compiled to uniquely identify and track this browser: `, headingStyle)
			console.log(propsReadAll)
			console.log(`%cSearch this host's Privacy Policy:`, headingStyle)
			console.log(`https://duckduckgo.com/?q=%22${domain}%22+%22privacy%22+%22policy%22`)
				console.groupCollapsed(`📋 Testing Resources`)
				console.log('https://privacycheck.sec.lrz.de/')
				console.log('https://ghacksuserjs.github.io/TorZillaPrint/TorZillaPrint.html')
				console.log('https://browserleaks.com/')
				console.log('https://webbrowsertools.com/')
				console.log('https://www.nothingprivate.ml')
				console.log('https://fingerprintjs.com/demo')
				console.log('https://bestiejs.github.io/platform.js/')
				console.groupEnd()
				console.groupCollapsed(`📝 Source Code Resources`)
				console.log('https://old.darkwavetech.com/fingerprint/fingerprint_code.html')
				console.log('https://github.com/Valve/fingerprintjs2')
				console.log('https://github.com/JackSpirou/ClientJS')
				console.groupEnd()
				console.groupCollapsed(`📚 Research Resources`)
				console.log('https://plaperdr.github.io/')
				console.log('https://docs.google.com/spreadsheets/d/1ZB1zINfGFcrcFzNg4eytRnBQN3nBoKHua2jhV_X6W80')
				console.groupEnd()
			console.groupEnd()
			watching = false
		}
		return newPropRead? trace: ()=>{}
	}
	// difinify
	function definify(struct) {
		const redefinedProps = {}
		Object.keys(struct).forEach(prop => {
			redefinedProps[prop] = { get: () => { watch(prop)(); return struct[prop] } }
		})
		return redefinedProps
	}
	function redefine(root, typeOfAttempt = '') {
		Object.defineProperties(root.navigator, definify(navigatorProps))
		Object.defineProperties(root.screen, definify(screenProps))
		Object.defineProperties(root.Date.prototype, definify(dateProps))
		Object.defineProperties(root.Intl.DateTimeFormat.prototype, definify(intlProps))
		Object.defineProperties(root.Math, definify(mathProps))
		Object.defineProperties(root.navigator.mediaDevices, definify(mediaDeviceProps))
		Object.defineProperties(root.HTMLVideoElement.prototype, definify(videoElementProps))
		Object.defineProperties(root.HTMLMediaElement.prototype, definify(mediaElementProps))
		Object.defineProperties(root.MediaSource, definify(mediaSourceProps))
		Object.defineProperties(root.MediaRecorder, definify(mediaRecorderProps))
		Object.defineProperties(root.speechSynthesis, definify(speechProps))
		Object.defineProperties(root.performance, definify(performanceProps))
		Object.defineProperties(root.Element.prototype, definify(elemRectProps))
		Object.defineProperties(root.Range.prototype, definify(rangeRectProps))
		Object.defineProperties(root.WebGLRenderingContext.prototype, definify(webglProps))
		Object.defineProperties(root.HTMLCanvasElement.prototype, definify(canvasProps))
		Object.defineProperties(root.CanvasRenderingContext2D.prototype, definify(canvasContextProps))
		Object.defineProperties(root.AudioContext.prototype, definify(audioProps))
		Object.defineProperties(root.AudioBuffer.prototype, definify(audioBufferProps))
	}
	redefine(window)
})()
