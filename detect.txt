# detect fingerprinting
detectfp.js application/javascript
(function() {
	// helpers
	const itemInList = (list, item) => list.indexOf(item) > -1
	const listRand = (list) => list[Math.floor(Math.random() * list.length)]
	const evenRand = (min, max) =>
		(Math.floor(Math.random() * ((max/2) - min + 1)) + min)*2
	const rand = (min, max) =>
		(Math.floor(Math.random() * (max - min + 1)) + min)
	// randomize
	const randomized = {}
	const doNotTrack = () => {
		const val = listRand(['0','1'])
		randomized.doNotTrack = ['doNotTrack', val]
		return val
	}
	function canLieTouch() {
	  const userAgent = navigator.userAgent
	  const os = (
	    /windows phone/ig.test(userAgent)? 'Windows Phone':
	    /win(dows|16|32|64|95|98|nt)|wow64/ig.test(userAgent)? 'Windows':
	    /android/ig.test(userAgent)? 'Android': 
	    /linux/ig.test(userAgent)? 'Linux': 
	    /ios/ig.test(userAgent)? 'iOS': 
	    /mac/ig.test(userAgent)? 'Mac': 
	    'Other' 
	  )
	  const chromeOS = /cros/ig.test(userAgent)
	  const touchOS = (/^(Windows(| Phone)|Android|iOS)$/ig.test(os) || chromeOS)
	  return touchOS
	}
	const maxTouchPoints = () => {
		const val = rand(1, 10)
		randomized.maxTouchPoints = ['maxTouchPoints', val]
		return val
	}
	const hardwareConcurrency = () => {
		const val = rand(1, 16)
		randomized.hardwareConcurrency = ['hardwareConcurrency', val]
		return val
	}
	const deviceMemory = () => {
		const val = evenRand(2, 32)
		randomized.deviceMemory = ['deviceMemory', val]
		return val
	}
	const screenRatio = listRand([{w:1920,h:1080},{w:1440,h:900},{w:1280,h:800},{w:1600,h:900}])
	const screenRandomized = (prop, val) => {
		randomized[prop] = [prop, val]
		return val
	}
	// structs
	const navigatorProps = {
		appVersion: navigator.appVersion,
		appCodeName: navigator.appCodeName,
		deviceMemory: deviceMemory(), // randomize
		doNotTrack: doNotTrack(), // randomize
		hardwareConcurrency: hardwareConcurrency(), // randomize
		languages: navigator.languages,
		maxTouchPoints: canLieTouch()? maxTouchPoints(): navigator.maxTouchPoints, // randomize if can lie
		mimeTypes: [],
		platform: navigator.platform,
		plugins: [],
		userAgent: navigator.userAgent,
		vendor: ''
	}
	const screenProps = {
		width: screenRandomized('screen.width', screenRatio.w),
		height: screenRandomized('screen.height', screenRatio.h),
		availWidth: screenRandomized('screen.availWidth', screenRatio.w-rand(1, 20)),
		availHeight: screenRandomized('screen.availHeight', screenRatio.h-rand(1, 20)),
		availTop: screen.availTop,
		availLeft: screen.availLeft,
		colorDepth: screen.colorDepth,
		pixelDepth: screen.pixelDepth
	}
	const dateProps = {
		getTimezoneOffset: Date.prototype.getTimezoneOffset
	}
	const intlProps = {
		resolvedOptions: Intl.DateTimeFormat.prototype.resolvedOptions
	}
	const mathProps = {
		acos: Math.acos,
		acosh: Math.acosh,
		asin: Math.asin,
		asinh: Math.asinh,
		cosh: Math.cosh,
		expm1: Math.expm1,
		sinh: Math.sinh
	}
	const mediaDeviceProps = {
		enumerateDevices: navigator.mediaDevices.enumerateDevices
	}
	const videoElementProps = {
		canPlayType: HTMLVideoElement.prototype.canPlayType
	}
	const mediaElementProps = {
		canPlayType: HTMLMediaElement.prototype.canPlayType
	}
	const mediaSourceProps = {
		isTypeSupported: MediaSource.isTypeSupported
	}
	const mediaRecorderProps = {
		isTypeSupported: MediaRecorder.isTypeSupported
	}
	const speechProps = {
		getVoices: [] // speechSynthesis.getVoices
	}
	const performanceProps = {
		now: performance.now
	}
	const elemRectProps = {
		getBoundingClientRect: Element.prototype.getBoundingClientRect,
		getClientRects: Element.prototype.getClientRects
	}
	const rangeRectProps = {
		getBoundingClientRect: Range.prototype.getBoundingClientRect,
		getClientRects: Range.prototype.getClientRects
	}
	const webglProps = {
		shaderSource: WebGLRenderingContext.prototype.shaderSource,
		getExtension: WebGLRenderingContext.prototype.getExtension,
		getParameter: WebGLRenderingContext.prototype.getParameter,
		getSupportedExtensions: WebGLRenderingContext.prototype.getSupportedExtensions
	}
	const canvasProps = {
		toDataURL: HTMLCanvasElement.prototype.toDataURL,
		toBlob: HTMLCanvasElement.prototype.toBlob
	}
	const canvasContextProps = {
		getImageData: CanvasRenderingContext2D.prototype.getImageData,
		isPointInPath: CanvasRenderingContext2D.prototype.isPointInPath,
		isPointInStroke: CanvasRenderingContext2D.prototype.isPointInStroke,
		measureText: CanvasRenderingContext2D.prototype.measureText,
	}
	const audioProps = {
		createAnalyser: AudioContext.prototype.createAnalyser,
		createOscillator: AudioContext.prototype.createOscillator,
	}
	// Log Randomized
	const style = () => {
		const colors = [
			`rgba(54,59,116,.${rand(1,6)})`,
			`rgba(103,56,136,.${rand(1,6)})`,
			`rgba(239,79,145,.${rand(1,9)})`,
			`rgba(199,157,215,.${rand(1,9)})`,
			`rgba(77,27,123,.${rand(1,6)})`
		]
		return `padding:4px 0px;background:${listRand(colors)};`
	}
	const randomizedKeys = Object.keys(randomized)
	const hash = randomizedKeys.map(key => randomized[key][1]).join('.')
	console.groupCollapsed(
		`🧪 Randomized ${randomizedKeys.length} properties (${hash})`
	)
	randomizedKeys.forEach(key => {
		const prop = randomized[key][0]
		const val = randomized[key][1]
		console.log(`%c${prop}: ${val}`, style())
	})
	console.groupEnd()
	// API with Ranking per Unique Impact and Longterm State
	const queryAPI = 'https://developer.mozilla.org/en-US/search?q='
	const propAPI = {
		appVersion: ['navigator.appVersion', 2],
		appCodeName: ['navigator.appCodeName', 1],
		deviceMemory: ['navigator.deviceMemory', 1],
		doNotTrack: ['navigator.doNotTrack', 1],
		hardwareConcurrency: ['navigator.hardwareConcurrency', 1],
		languages: ['navigator.languages', 1],
		maxTouchPoints: ['navigator.maxTouchPoints', 1],
		mimeTypes: ['navigator.mimeTypes', 1],
		platform: ['navigator.platform', 1],
		plugins: ['navigator.plugins', 1],
		userAgent: ['navigator.userAgent', 2],
		vendor: ['navigator.vendor', 1],
		width: ['screen.width', 1],
		height: ['screen.height', 1],
		availWidth: ['screen.availWidth', 1],
		availHeight: ['screen.availHeight', 1],
		availTop: ['screen.availTop', 1],
		availLeft: ['screen.availLeft', 1],
		colorDepth: ['screen.colorDepth', 1],
		pixelDepth: ['screen.pixelDepth', 1],
		getTimezoneOffset: ['Date.prototype.getTimezoneOffset', 1],
		resolvedOptions: ['Intl.DateTimeFormat.prototype.resolvedOptions', 2],
		acos: ['acos: Math.acos', 1],
		acosh: ['Math.acosh', 1],
		asin: ['Math.asin', 1],
		asinh: ['Math.asinh', 1],
		cosh: ['Math.cosh', 1],
		expm1: ['Math.expm1', 1],
		sinh: ['Math.sinh', 1],
		enumerateDevices: ['navigator.mediaDevices.enumerateDevices', 1],
		canPlayType: ['prototype.canPlayType', 1],
		isTypeSupported: ['isTypeSupported', 1],
		getVoices: ['speechSynthesis.getVoices', 1],
		now: ['performance.now', 1],
		getBoundingClientRect: ['prototype.getBoundingClientRect', 2],
		getClientRects: ['prototype.getClientRects', 2],
		offsetWidth: ['HTMLElement.prototype.offsetWidth', 1],
		offsetHeight: ['HTMLElement.prototype.offsetHeight', 1],
		shaderSource: ['WebGLRenderingContext.prototype.shaderSource', 6],
		getExtension: ['WebGLRenderingContext.prototype.getExtension', 2],
		getParameter: ['WebGLRenderingContext.prototype.getParameter', 2],
		getSupportedExtensions: ['WebGLRenderingContext.prototype.getSupportedExtensions', 4],
		toDataURL: ['HTMLCanvasElement.prototype.toDataURL', 6],
		toBlob: ['HTMLCanvasElement.prototype.toBlob', 6],
		getImageData: ['CanvasRenderingContext2D.prototype.getImageData', 6],
		isPointInPath: ['CanvasRenderingContext2D.prototype.isPointInPath', 1],
		isPointInStroke: ['CanvasRenderingContext2D.prototype.isPointInStroke', 1],
		measureText: ['CanvasRenderingContext2D.prototype.measureText', 1],
		font: ['CanvasRenderingContext2D.prototype.font', 1],
		createAnalyser: ['AudioContext.prototype.createAnalyser', 6],
		createOscillator: ['AudioContext.prototype.createOscillator', 6]
	}
	// watcher
	let rankCounter = 0
	let watching = true
	const domain = window.location.hostname
	const fingerprintingRank = 12
	const propsRead = []
	const propsReadAll = {}
	const watch = (prop) => {
		const propDescription = propAPI[prop][0]
		const propRank = propAPI[prop][1]
		const trace = () => {
			const emojis = propRank >= 6? '🥵': propRank >= 4? '🥶': propRank >= 3? '😱': propRank >=2 ? '😨': ''
			console.groupCollapsed(`${emojis} Script read ${propDescription}`)
			console.log(`%cAPI REFERENCE: ${queryAPI+propDescription}`, `color:blue;background:#8eca8e4d;padding:2px;`)
			console.log('Attempting to trace the source (refresh to retry)...')
			console.trace(document.currentScript?document.currentScript.src:'')
			console.groupEnd()
		}
		const newPropRead = !itemInList(propsRead, propDescription)
		propsReadAll[propDescription]? propsReadAll[propDescription]++: propsReadAll[propDescription]=1
		if (newPropRead) {
			rankCounter += propRank
			propsRead.push(propDescription)
		}
		// counter types
		if (watching && rankCounter >= fingerprintingRank) {
			const warnStyle = `color:green;border:2px solid green;font-weight:bold;padding:5px;`
			console.warn(`%c⚔️ Finterprinting detected!`, warnStyle)
			console.groupCollapsed(`📔 Finterprinting Stats`)
			console.log(`Total properties read (your data collected): `, propsRead)
			console.log(`Total reads per property (how many times your data was collected): `, propsReadAll)
			console.log(`Search this host's Privacy Policy: https://duckduckgo.com/?q=%22${domain}%22+%22privacy%22+%22policy%22`)
			console.groupEnd()
			watching = false
		}
		return newPropRead? trace: ()=>{}
	}
	// difinify
	function definify(struct) {
		const redefinedProps = {}
		Object.keys(struct).forEach(prop => {
			redefinedProps[prop] = { get: () => { watch(prop)(); return struct[prop] } }
		})
		return redefinedProps
	}
	function redefine(root, typeOfAttempt = '') {
		Object.defineProperties(root.navigator, definify(navigatorProps))
		Object.defineProperties(root.screen, definify(screenProps))
		Object.defineProperties(root.Date.prototype, definify(dateProps))
		Object.defineProperties(root.Intl.DateTimeFormat.prototype, definify(intlProps))
		Object.defineProperties(root.Math, definify(mathProps))
		Object.defineProperties(root.navigator.mediaDevices, definify(mediaDeviceProps))
		Object.defineProperties(root.HTMLVideoElement.prototype, definify(videoElementProps))
		Object.defineProperties(root.HTMLMediaElement.prototype, definify(mediaElementProps))
		Object.defineProperties(root.MediaSource, definify(mediaSourceProps))
		Object.defineProperties(root.MediaRecorder, definify(mediaRecorderProps))
		Object.defineProperties(root.speechSynthesis, definify(speechProps))
		Object.defineProperties(root.performance, definify(performanceProps))
		Object.defineProperties(root.Element.prototype, definify(elemRectProps))
		Object.defineProperties(root.Range.prototype, definify(rangeRectProps))
		Object.defineProperties(root.WebGLRenderingContext.prototype, definify(webglProps))
		Object.defineProperties(root.HTMLCanvasElement.prototype, definify(canvasProps))
		Object.defineProperties(root.CanvasRenderingContext2D.prototype, definify(canvasContextProps))
		Object.defineProperties(root.AudioContext.prototype, definify(audioProps))
	}
	redefine(window)
})()
